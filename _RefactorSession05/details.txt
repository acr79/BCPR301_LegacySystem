0502

Python Document:
    Controller.py (original)
LOC:
    58-92

The smell identified is alternative classes with different interfaces. First,
 it must be clarified that the classes have identical functionality from the
 perspective of the Controller only. What is happening is that the classes
 Record, Option, and RecordCollection are getting represented as a string, and
 the Controller has two selected-object attributes: One of Record, one of
 Option, and these can be None. There is currently a rule that the Controller
 can only have an Option selected or a Record selected, i.e. at all times
 at least one of _selectedRecord and _selectedOption must be None - or, with
 extensibility in mind, only one of these attributes can refer to something
 other than None.

Common behaviour
- Can be selected as an object
- String representation

It is possible that Record and Option can adopt an interface that matches the
 behaviour above, but this generalisation is from the perspective of the
 Controller only. In this case it might be ideal to introduce composite
 classes, that will refer to an instance of Record or Option.

Ideal methods of Controller

   def _


The interface (practically an abstract class)


class AbstractSelectable(metaclass=ABCMeta):


    @abstractmethod
    def getAsString(self):
        pass

    @abstractmethod
    def getFunctionDesc(self):
        pass

    @abstractmethod
    def getClassObject(self):
        pass


Implementers

class RecordSelectable(AbstractSelectable):

    def __init__(self, newRecord, functionDesc):
        if not isinstance(newRecord, Record):
            raise CustomException("Not a Record object")
        self._record = newRecord
        self._funcStr = functionDesc

    def getAsString(self):
        return "ID: {}\nGENDER: {}\nAGE: {}\nSALES: {}\nBMI: {}\nINCOME: \
{}\n".format(self._record.getID(), self._record.getGender(),
             self._record.getAge(), self._record.getSales(),
             self._record.getBMI(), self._record.getIncome())

    def getFunctionDesc(self):
        return self._funcStr

    def getClassObject(self):
        return self._theRecord


class OptionSelectable(AbstractSelectable):

    def __init__(self, newOption, functionDesc):
        if not isinstance(self, newOption):
            raise customException("Not an Option object")
        self._option = newOption
        self._funcStr = functionDesc

    def getAsString(self):
        state = "OFF"
        if self._option.isOn():
            state = "ON"
        return "{}: TURNED {}\n. . .\nON: {}\nOFF: {}\n\n\
".format(self._option.getName(), state, self._option.getOnDescription(),
         self._option.getOffDescription())

    def getFunctionDesc(self):
        return self._funcStr

    def getClassObject(self):
        return self._option

Controller can even implement AbstractSelectable

    def getAsString(self):
        return "Records in ERP: {}".format(len(self._theColl.getAllRecords())

    def getFunctionDesc(self):
        return ""

    def getClassObject(self):
        return self



Controller class could then just have one attribute of type AbstractSelectable

On __init__():
        self._selectedObject = self

    def _showSelectedState(self, headerStr):
        self.myView.show(headerStr)
        self.myView.show(self._selectedObject.getAsString())
        self.myView.show(self._selectedObject.getFunctionDesc())

    def do_select_rec(self, arg):
        trial = self._theColl.getRecord(arg)
        if trial is not None:
            self._selectedObject = RecordSelectable(trial, "Use the \
following with the appropriate argument to edit the record:\n+ edit_age\n+ \
edit_sales\n+ edit_bmi\n+ edit_income\n")
            self._showSelectedState("Selected Record")
        else:
            self._myView.show("There is no record with that ID\n")
            self._selectedObject = self

    def do_select_option(self, arg):
        trial = arg.upper()
        if trial in self._options:
            self._selectedObject = OptionSelectable(self._options[trial], "\
Use the following to set the option:\n+ on\n+ off\n")
            self._showSelectedState("Selected Option")
        else:
            self._myView.show("There is not option\n")
            self._selectedObject = self

The AbstractSelectable is not limited to use of Controller's selected object

    def do_view_options(self, arg):
        for code in self._options:
            theOption = OptionSelectable(self._options[code], "")
            self._myView.show("Option Code: {}".format(code))
            self._myView.show(theOption.getAsString())



Additional methods

    def _checkRecordSelected(self):
        trial = self._selectedObject.getClassObject()
        if isinstance(trial, Record):
            return True
        else
            self._myView.show("No record selected")
            return False

    def _checkOptionSelected(self):
        trial = self._selectedObject.getClassObject()
        if isinstance(trial, Option):
            return True
        else
            self._myView.show("No option selected")
            return False


class AbstractObjectCaller(metaclass=ABCMeta):

    @abstractmethod
    def setObject(self, theObject):
        pass

    @abstractmethod
    def callObject(self):
        pass


class RecordObjectCaller(AbstractObjectCaller):

    _errStr = "No record selected"

    def __init__(self, newData):
        self._record = None
        self._newData = newData

    def setObject(self, theObject):
        if not isinstance(theObject, Record):
            raise CustomException(RecordObjectCaller._errStr)
        self._record = theObject

    def callObject(self):
        if self._record is None:
            raise CustomException(RecordObjectCaller._errStr)


class ROC_SetAge(RecordObjectCaller):

    def callObject(self):
        super().callObject()
        self._record.setAge(self._newData)


class ROC_SetSales(RecordObjectCaller):

    def callObject(self):
        super().callObject()
        self._record.setSales(self._newData)


class ROC_SetBMI(RecordObjectCaller):

    def callObject(self):
        super().callObject()
        self._record.setBMI(self._newData)


class ROC_SetIncome(RecordObjectCaller):

    def callObject(self):
        super().callObject()
        self._record.setIncome(self._newData)


class OptionObjectCaller(AbstractObjectCaller):

    _errStr = "No option selected"

    def __init__(self):
        self._option = None

    def setObject(self, theObject):
        if not isinstance(theObject, Option):
            raise CustomException(OptionObjectCaller._errStr)
        self._option = theObject

    def callObject(self):
        if self._option is None:
            raise CustomException(OptionObjectCaller._errStr)


class OOC_TurnOn(OptionObjectCaller):

    def callObject(self):
        super().callObject()
        self._option.turnOn()


class OOC_TurnOff(OptionObjectCaller):

    def callObject(self):
        super().callObject()
        self._option.turnOff()






