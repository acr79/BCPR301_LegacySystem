LARGE CLASS

Controller

+ prompt : String
# myView : View
# options : Dictionary(String : Option)
# theColl : RecordCollection
# selectedRecord : Record
# selectedOption : Option

# add(data : String);
# stall();
# representRecord(theRecord : Record);
# representOption(theOption : Option);
# representERP();
# enterRecordSelectedState();
# enterOptionSelectedState();
# enterNeutralState();
+ do: view_records(arg : String);
+ do: view_options(arg : String);
+ do: graphic_gender_pie_chart(arg : String);
+ do: graphic_age_bar_chart(arg : String);
+ do: select_rec(arg : String);
+ do: select_option(arg : String);
+ do: text_load(arg : String); - FILER
+ do: text_save(arg : String); - FILER
+ do: serial_load(arg : String);
+ do: serial_save(arg : String); - FILER
+ do: add_rec(arg : String);
+ do: edit_age(arg : String);
+ do: edit_sales(arg : String);
+ do: edit_bmi(arg : String);
+ do: edit_income(arg : String);
+ do: on(arg : String);
+ do: off(arg : String);
+ do: neutral(arg : String);
+ do: exit(arg : String);
+ do: help(arg : String);

text_load
  Opening the file, reading all lines, closing the file
  IOError handling

text_save
  Checking that the specified file does not exist
  Creating the file, writing all lines, closing the file
  IOError handling

serial_save
  Checking that the specified file does not exist
  Creating the file, object storage, closing the file
  IOError handling

The nature of Controller inheriting from cmd.Cmd means that it will still
 possess these methods, but it can use other (at least one other) class to
 delegate tasks to. The three filer methods should be delegated to a class
 that will deal with text files. It is predicted that this will relieve
 Controller of dealing with IOError and filer rules and, some changes to a
 dedicated filer will not involve changing the methods of Controller.

Also, this proposed Filer class could also have another method called
 serial_load(), which would load a RecordCollection object, but Controller
 will not call this as per its current restriction - serial_load() can be
 called in the RunMain module when constructing the Controller.

Testing these methods before and after refactoring will require the open()
 (from builtins) and os.path.isfile() methods to be mocked, as the testing
 method will have the mocked open() method return either a text I/O stream or
 a binary I/O stream, and set os.path.isfile() to return the desired value
 depending on the situation. The I/O streams will be set in the test cases.

Also, in keeping with the behaviour of the ERP, a serial load can only
 be done before construction of the Controller, which is in the main() method
 of RunMain module. Testing a serial load would have to include the importing
 of RunMain - a small modification has been done to the original class schema
 so that RunMain.theController refers to an instance of Controller, which will
 be ready to use after calling RunMain.main(). As the purpose of a serial load
 is to construct a Controller with a reference to the loaded RecordCollection,
 tests can be done to assert this reference is correctly made.

An adjustment has been made to the original schema. The type required by
 Controller is now AbstractView, with View and TestView as implementers. The
 motivation here is that the supposed output of performing filer actions is
 sent to a view, by the method View().show(parameter), where the parameter
 value is of interest. In order to check what is being passed to show() when
 exercised by the Controller, unit testing will provide an instance of
 TestView, a class which keeps track of calls to show() and stall(). Calls to
 show(parameter) have the parameter appended to a list called theLog, and
 a call to stall() increases the value of theStalls by 1 (it starts at 0):
 Both of these are found in the module TestView.py.

  
#D = Controller keeps this in delegate method
#R = Reference needs to be made to Controller
#P = From paramter

    def serialLoad(arg):
        report = ""
        import pickle
        x = None
        try:
            with open(arg, 'rb') as f:
                x = pickle.load(f)
        except IOError as e:
            report = "Failed to do serial load: {}\n".format(str(e))
        except AttributeError as e:
            report += "Failed to do serial load: {}\n".format(str(e))
        if isinstance(x, RecordCollection):
            report += "Serial load of record collection successful\n"
            return (x, report)
        else:
            return (None, report)

    def text_load(self, arg):
        """
        Load records from a text file; depending on their IDs and the options,
        ERP will attempt to append all records to the collection
        arg: The loaction of the text file
        """
        #D self._enterNeutralState()
        try:
            theFile = open(arg, 'r')
            theLines = theFile.readlines()
            theFile.close()
            added = 0
            report = ""
            for i in range(len(theLines)):
                data = ""
                if 0 < len(theLines[i]) and theLines[i][-1] == '\n':
                    data = theLines[i][0:-1]
                else:
                    data = theLines[i]
                try:
                    #R self._add(data)
                except CustomException as e:
                    report += "BAD LINE {}: {}\n".format(i + 1, str(e))
                else:
                    added += 1
        except IOError as e:
            self._myView.show("EXCEPTION: {}\n".format(str(e)))
        else:
            self._myView.show("Records Added: {}\nProblems: \n{}\n\
".format(added, report))
        #D self._stall()

    def do_serial_save(self, arg):
        """
        Save records as serial data
        arg: The location of the text file
        Please specify a non existing file
        For instructions on loading serial data, please command serial_load
        """
        import pickle
        import os
        if not os.path.isfile(arg):  # protection from overwriting files
            try:
                with open(arg, 'wb') as f:
                    pickle.dump(#P self._theColl, f)
            except IOError as e:
                #P self._myView.show("EXCEPTION: {}\n".format(str(e)))
        else:
            #P self._myView.show("Will not overwrite an existing file\n\
Please, enter a new file when using serial_save\n")
        #D self._enterNeutralState()

    def do_text_save(self, arg):
        """
        Save records to a text file
        arg: The location of the text file
        Please specify a non existing file
        """
        import os
        if not os.path.isfile(arg):
            try:
                theFile = open(arg, 'w')

                # in this section, it would be ideal
                #  to submit all the lines to be written as a parameter
                theLines = []
                allRecords = self._theColl.getAllRecords()
                total = len(allRecords)
                for i in range(total):
                    r = allRecords[i]
                    asStr = "{} {} {} {} {} {}".format(r.getID(),
                                                       r.getGender(),
                                                       r.getAge(),
                                                       r.getSales(),
                                                       r.getBMI(),
                                                       r.getIncome())
                    if i < (total - 1):
                        asStr += "\n"
                    theLines.append(asStr)
                theFile.writelines(theLines)
                theFile.close()
            except IOError as e:
                #P self._myView.show("EXCEPTION: {}\n".format(str(e)))
            else:
                #P self._myView.show("Saved As Text")
            #D self._stall()
        else:
            #P self._myView.show("Will not overwrite an existing file\n\
Please, enter a new file when using serial_save\n")
        #D self._enterNeutralState()
